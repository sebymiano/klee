#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ===-- ktest-tool --------------------------------------------------------===##
# 
#                      The KLEE Symbolic Virtual Machine
# 
#  This file is distributed under the University of Illinois Open Source
#  License. See LICENSE.TXT for details.
# 
# ===----------------------------------------------------------------------===##

import binascii
import io
import os
import string
import struct
import sys

version_no=4


class KTestError(Exception):
    pass


class KTest:
    valid_chars = string.digits + string.ascii_letters + string.punctuation + ' '

    @staticmethod
    def fromfile(path):
        try:
            f = open(path, 'rb')
        except IOError:
            print("ERROR: file %s not found" % path)
            sys.exit(1)

        hdr = f.read(5)
        if len(hdr) != 5 or (hdr != b'KTEST' and hdr != b"BOUT\n"):
            raise KTestError('unrecognized file')
        version, = struct.unpack('>i', f.read(4))
        if version > version_no:
            raise KTestError('unrecognized version')
        numArgs, = struct.unpack('>i', f.read(4))
        args = []
        for i in range(numArgs):
            size, = struct.unpack('>i', f.read(4))
            args.append(str(f.read(size).decode(encoding='ascii')))

        if version >= 2:
            symArgvs, = struct.unpack('>i', f.read(4))
            symArgvLen, = struct.unpack('>i', f.read(4))
        else:
            symArgvs = 0
            symArgvLen = 0

        numObjects, = struct.unpack('>i', f.read(4))
        objects = []
        for i in range(numObjects):
            size, = struct.unpack('>i', f.read(4))
            name = f.read(size).decode('utf-8')
            size, = struct.unpack('>i', f.read(4))
            bytes = f.read(size)
            objects.append((name, bytes))

        havocs = []
        if version >= 4:
            numHavocs, = struct.unpack('>i', f.read(4))
            for i in range(numHavocs):
                size, = struct.unpack('>i', f.read(4))
                name = f.read(size)
                size, = struct.unpack('>i', f.read(4))
                bytes = f.read(size)
                mask_size = (size + 31)/32*4
                mask = f.read(mask_size)
                havocs.append( (name,bytes,mask) )
        # Create an instance
        b = KTest(version, args, symArgvs, symArgvLen, objects, havocs)
        # Augment with extra filename field
        b.filename = path
        return b
    
    def __init__(self, version, args, symArgvs, symArgvLen, objects, havocs):
        self.version = version
        self.path = path
        self.symArgvs = symArgvs
        self.symArgvLen = symArgvLen
        self.args = args
        self.objects = objects
        self.havocs = havocs

    def __format__(self, format_spec):
        sio = io.StringIO()
        width = str(len(str(max(1, len(self.objects) - 1))))

        # print ktest info
        print('ktest file : %r' % self.path, file=sio)
        print('args       : %r' % self.args, file=sio)
        print('num objects: %r' % len(self.objects), file=sio)

        # format strings
        fmt = dict()
        fmt['name'] = "object {0:" + width + "d}: name: '{1}'"
        fmt['size'] = "object {0:" + width + "d}: size: {1}"
        fmt['int' ] = "object {0:" + width + "d}: int : {1}"
        fmt['uint'] = "object {0:" + width + "d}: uint: {1}"
        fmt['data'] = "object {0:" + width + "d}: data: {1}"
        fmt['hex' ] = "object {0:" + width + "d}: hex : 0x{1}"
        fmt['text'] = "object {0:" + width + "d}: text: {1}"

        # print objects
        for i, (name, data) in enumerate(self.objects):
            def p(key, arg): print(fmt[key].format(i, arg), file=sio)

            blob = data.rstrip(b'\x00') if format_spec.endswith('trimzeros') else data
            txt = ''.join(c if c in self.valid_chars else '.' for c in blob.decode('ascii', errors='replace').replace('ï¿½', '.'))
            size = len(data)

            p('name', name)
            p('size', size)
            p('data', blob)
            p('hex', binascii.hexlify(blob).decode('ascii'))
            for n, m in [(1, 'b'), (2, 'h'), (4, 'i'), (8, 'q')]:
                if size == n:
                    p('int', struct.unpack(m, data)[0])
                    p('uint', struct.unpack(m.upper(), data)[0])
                    break
            p('text', txt)

        return sio.getvalue()


def main():
    from optparse import OptionParser
    op = OptionParser("usage: %prog [options] files")
    op.add_option('', '--trim-zeros', dest='trimZeros', action='store_true',
                  default=False,
                  help='trim trailing zeros')

    opts, args = op.parse_args()
    if not args:
        op.error("incorrect number of arguments")

    for file in args:
        ktest = KTest.fromfile(file)
        fmt = '{:trimzeros}' if opts.trimZeros else '{}'
        print(fmt.format(ktest), end='')

            print('object %4d: name: %r' % (i, name))
            print('object %4d: size: %r' % (i, len(data)))
            if opts.writeInts and len(data) == 4: 
                print('object %4d: data: %r' % (i, struct.unpack('i',str)[0]))
            else:
                print('object %4d: data: %r' % (i, str))
        print('num havocs: %r' % len(b.havocs))
        for i,(name,data,mask) in enumerate(b.havocs):
            if opts.trimZeros:
                str = trimZeros(data)
            else:
                str = data

            print('havoc %4d: name: %r' % (i, name))
            print('havoc %4d: size: %r' % (i, len(data)))
            print('havoc %4d: mask: %r' % (i, mask))
            if opts.writeInts and len(data) == 4: 
                print('havoc %4d: data: %r' % (i, struct.unpack('i',str)[0]))
            else:
                print('havoc %4d: data: %r' % (i, str))
        if file != args[-1]:
            print()


if __name__=='__main__':
    main()
